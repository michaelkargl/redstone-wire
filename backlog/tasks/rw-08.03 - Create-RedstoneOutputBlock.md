---
id: RW-08.03
title: Create RedstoneOutputBlock
status: To Do
assignee: []
created_date: '2026-02-14 19:41'
updated_date: '2026-02-14 19:49'
labels:
  - feature
milestone: m-1
dependencies:
  - RW-08.01
references:
  - src/main/java/at/osa/redstonewire/RedstoneChainBlock.java
parent_task_id: RW-08
priority: high
---

## Description

<!-- SECTION:DESCRIPTION:BEGIN -->
Create the Output block that takes signal from the cable network and emits it to surrounding blocks.

Extends AbstractRedstoneChainBlock:
- Adds POWER property (0-15) via createBlockStateDefinition() and registers default state with POWER=0
- neighborChanged() — no-op (does NOT detect external signals)
- isSignalSource() returns true when POWER > 0 (emits signal)
- getSignal() returns POWER value from block state or entity
- getDirectSignal() returns 0 (indirect power only, like redstone dust)
- hasAnalogOutputSignal() returns true
- getAnalogOutputSignal() returns POWER value
- getTicker() returns null (Output blocks don't tick)
<!-- SECTION:DESCRIPTION:END -->

## Acceptance Criteria
<!-- AC:BEGIN -->
- [ ] #1 RedstoneOutputBlock.java exists extending AbstractRedstoneChainBlock
- [ ] #2 Has POWER property (0-15) with default state POWER=0
- [ ] #3 neighborChanged() is a no-op
- [ ] #4 isSignalSource() returns true when POWER > 0
- [ ] #5 getSignal() returns POWER value, getDirectSignal() returns 0
- [ ] #6 Comparator can read the output signal level
- [ ] #7 getTicker() returns null
<!-- AC:END -->

## Implementation Plan

<!-- SECTION:PLAN:BEGIN -->
## Implementation Plan

### 1. Create `RedstoneOutputBlock.java`
Location: `src/main/java/at/osa/redstonewire/RedstoneOutputBlock.java`

### 2. Class structure
```java
public class RedstoneOutputBlock extends AbstractRedstoneChainBlock {
    public static final IntegerProperty POWER = BlockStateProperties.POWER;

    public RedstoneOutputBlock(Properties properties) {
        super(properties);
        this.registerDefaultState(this.stateDefinition.any().setValue(POWER, 0));
    }

    @Override
    protected void createBlockStateDefinition(Builder builder) {
        builder.add(POWER);
    }

    // neighborChanged() → no-op (does not detect external signals)
    // isSignalSource() → state.getValue(POWER) > 0
    // getSignal() → entity.getSignal() or state.getValue(POWER)
    // getDirectSignal() → 0
    // hasAnalogOutputSignal() → true
    // getAnalogOutputSignal() → state.getValue(POWER)
}
```

### 3. Key decisions
- `getSignal()` implementation mirrors legacy block: check entity first, fall back to block state
- `neighborChanged()` is intentionally empty — Output should NOT trigger network recalculation
- No ticker needed — Output blocks are updated by the network propagation from Input blocks
- `isSignalSource()` returns true conditionally (only when powered), matching legacy behavior

### 4. Verify
- Compiles with `./gradlew build`
<!-- SECTION:PLAN:END -->

## Implementation Notes

<!-- SECTION:NOTES:BEGIN -->
## Implementation Notes

### getSignal() implementation detail
The Output block's `getSignal()` should check the entity first for consistency with the legacy block:
```java
BlockEntity be = level.getBlockEntity(pos);
if (be instanceof RedstoneChainEntity chain) {
    return chain.getSignal();
}
return state.getValue(POWER);
```
However, since `RedstoneChainEntity.getSignal()` will be updated in RW-08.05 to guard against Connector blocks, this will correctly return the POWER value for Output blocks.

### Why neighborChanged is a no-op
Output blocks exist solely to emit signals. They don't need to detect external changes because:
1. The network signal is pushed to them by `applySignalToNetwork()` from the Input block's entity
2. If they reacted to neighbor changes, they could create feedback: Output powers lamp → lamp neighbor update → Output re-triggers → loop

### Power emission pattern
Like the legacy block, Output uses indirect power only (`getDirectSignal()` returns 0). This means:
- A lamp placed adjacent to the Output block WILL light up (indirect power through block)
- A repeater reading from the Output block WILL pick up the signal
- Redstone dust placed next to the Output block WILL receive signal

### No ticker needed
Output blocks don't tick. They receive their POWER state passively when `applySignalToNetwork()` is called by any Input block's entity in the same network. This is a key simplification over the legacy block where every block ticked.
<!-- SECTION:NOTES:END -->

## Definition of Done
<!-- DOD:BEGIN -->
- [ ] #1 New file `RedstoneOutputBlock.java` exists in `at.osa.redstonewire` package
- [ ] #2 Class extends `AbstractRedstoneChainBlock`
- [ ] #3 Defines `POWER` property via `createBlockStateDefinition(builder.add(POWER))`
- [ ] #4 Constructor calls `registerDefaultState(stateDefinition.any().setValue(POWER, 0))`
- [ ] #5 `neighborChanged()` is a no-op (empty method body, only `super` call if needed)
- [ ] #6 `isSignalSource()` returns `true` when `state.getValue(POWER) > 0`
- [ ] #7 `getSignal()` returns POWER value from block state (or entity fallback)
- [ ] #8 `getDirectSignal()` returns `0`
- [ ] #9 `hasAnalogOutputSignal()` returns `true`, `getAnalogOutputSignal()` returns POWER value
- [ ] #10 `getTicker()` returns `null` (inherits from base, no override needed)
- [ ] #11 Output block powers adjacent lamp when POWER > 0
- [ ] #12 Project compiles with `./gradlew build`
<!-- DOD:END -->
