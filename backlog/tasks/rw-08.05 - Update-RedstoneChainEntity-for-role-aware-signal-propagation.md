---
id: RW-08.05
title: Update RedstoneChainEntity for role-aware signal propagation
status: To Do
assignee: []
created_date: '2026-02-14 19:41'
updated_date: '2026-02-14 19:50'
labels:
  - refactor
milestone: m-1
dependencies:
  - RW-08.02
  - RW-08.03
  - RW-08.04
references:
  - src/main/java/at/osa/redstonewire/RedstoneChainEntity.java
parent_task_id: RW-08
priority: high
---

## Description

<!-- SECTION:DESCRIPTION:BEGIN -->
Modify RedstoneChainEntity to be role-aware, checking block types at each network position to determine behavior.

Key changes:

1. computeNetworkInputPower() — Only scan neighbors of RedstoneInputBlock positions:
   - Add instanceof RedstoneInputBlock check, skip all other block types
   
2. getPowerFromDirection() — Update instanceof check to skip all chain-type blocks:
   - Change: `block instanceof RedstoneChainBlock` to `block instanceof AbstractRedstoneChainBlock || block instanceof RedstoneChainBlock`

3. applySignalToNetwork() — Skip Connector blocks (no POWER property):
   - Check instanceof RedstoneConnectorBlock and skip
   - For Input/Output blocks, safely read/write POWER via AbstractRedstoneChainBlock.POWER

4. getSignal() — Guard against Connector blocks:
   - If block is RedstoneConnectorBlock, return 0 (no POWER property to read)
   - Otherwise read POWER from block state as before

5. getConnectedChains() — No change needed (checks for RedstoneChainEntity which all types share)

Note: The POWER static field will be defined identically in both RedstoneInputBlock and RedstoneOutputBlock (both use BlockStateProperties.POWER). The entity should reference it via the block state safely.
<!-- SECTION:DESCRIPTION:END -->

## Acceptance Criteria
<!-- AC:BEGIN -->
- [ ] #1 computeNetworkInputPower() only scans neighbors of RedstoneInputBlock positions
- [ ] #2 getPowerFromDirection() skips AbstractRedstoneChainBlock and legacy RedstoneChainBlock neighbors
- [ ] #3 applySignalToNetwork() skips RedstoneConnectorBlock (no POWER property)
- [ ] #4 getSignal() returns 0 for Connector blocks instead of crashing
- [ ] #5 Entity still works correctly with legacy RedstoneChainBlock in mixed networks
- [ ] #6 No regressions in feedback loop protection or signal loss delay
<!-- AC:END -->

## Implementation Plan

<!-- SECTION:PLAN:BEGIN -->
## Implementation Plan

### 1. Modify `computeNetworkInputPower()` (line 530)
Add an instanceof guard at the start of the loop body:
```java
for (BlockPos pos : network) {
    if (!(level.getBlockState(pos).getBlock() instanceof RedstoneInputBlock)) continue;
    int powerAtBlock = findMaxPowerAroundBlock(pos);
    maxInput = Math.max(maxInput, powerAtBlock);
}
```
This ensures only Input block positions are scanned for external power.

### 2. Modify `getPowerFromDirection()` (line 571)
Change the instanceof check from:
```java
if (block instanceof RedstoneChainBlock) return 0;
```
To:
```java
if (block instanceof AbstractRedstoneChainBlock || block instanceof RedstoneChainBlock) return 0;
```
This ensures new block types are also skipped when scanning for external power.

### 3. Modify `applySignalToNetwork()` (line 619)
Replace the single `instanceof RedstoneChainBlock` check with multi-type logic:
```java
for (BlockPos pos : network) {
    BlockState state = level.getBlockState(pos);
    Block block = state.getBlock();
    if (block instanceof RedstoneConnectorBlock) continue;  // No POWER property
    if (block instanceof RedstoneChainBlock) {
        // Legacy block
        int old = state.getValue(RedstoneChainBlock.POWER);
        if (old != signal) level.setBlock(pos, state.setValue(RedstoneChainBlock.POWER, signal), 3);
    } else if (block instanceof AbstractRedstoneChainBlock) {
        // Input or Output block — both have POWER via BlockStateProperties.POWER
        int old = state.getValue(BlockStateProperties.POWER);
        if (old != signal) level.setBlock(pos, state.setValue(BlockStateProperties.POWER, signal), 3);
    }
}
```

### 4. Modify `getSignal()` (line 847)
Add Connector guard:
```java
public int getSignal() {
    BlockState state = getBlockState();
    if (state.getBlock() instanceof RedstoneConnectorBlock) return 0;
    if (state.getBlock() instanceof RedstoneChainBlock) return state.getValue(RedstoneChainBlock.POWER);
    return state.getValue(BlockStateProperties.POWER);
}
```

### 5. No changes needed to:
- `getConnectedChains()` — already checks `instanceof RedstoneChainEntity` (shared by all types)
- `rebuildNetwork()` — same pattern
- Serialization methods — unchanged
- `tick()` — unchanged (called only on Input blocks via getTicker)

### 6. Verify
- `./gradlew build` compiles
- Add imports for new types: `RedstoneInputBlock`, `RedstoneConnectorBlock`, `AbstractRedstoneChainBlock`
<!-- SECTION:PLAN:END -->

## Implementation Notes

<!-- SECTION:NOTES:BEGIN -->
## Implementation Notes

### Using BlockStateProperties.POWER vs block-specific POWER
Both `RedstoneInputBlock.POWER` and `RedstoneOutputBlock.POWER` are aliases for `BlockStateProperties.POWER`. In the entity code, we can reference `BlockStateProperties.POWER` directly when dealing with new block types. For legacy blocks, we reference `RedstoneChainBlock.POWER` (also the same underlying property). Using `BlockStateProperties.POWER` is cleaner as it avoids needing to know which specific subclass we're dealing with.

### Why Connector skip is critical
`RedstoneConnectorBlock` has no POWER property in its blockstate definition. Calling `state.getValue(BlockStateProperties.POWER)` on a Connector would throw `IllegalArgumentException: Cannot get property power...`. The `instanceof RedstoneConnectorBlock` skip must come BEFORE any POWER access.

### computeNetworkInputPower change impact
Currently, the method scans ALL network positions for external power. After this change, it only scans Input positions. This means:
- A lever next to an Output block will NOT power the network (intended behavior)
- A lever next to a Connector block will NOT power the network (intended behavior)
- Only levers/sources next to Input blocks feed signal into the network

For legacy blocks in the same network (mixed network), they're not `instanceof RedstoneInputBlock`, so they'll be skipped too. This is acceptable — legacy blocks in a mixed network behave as Connector-like nodes. Pure legacy networks still work because legacy blocks don't use this entity path (they use `findNetwork()`/`findPower()` via `tick()`).

### getPowerFromDirection — both checks needed
The new blocks extend `AbstractRedstoneChainBlock`, not `RedstoneChainBlock`. Without adding the `AbstractRedstoneChainBlock` instanceof check, the entity would try to read redstone signal from new block types as if they were external sources, creating feedback.

### Order of instanceof checks in applySignalToNetwork
Check `RedstoneConnectorBlock` first (skip), then `RedstoneChainBlock` (legacy), then `AbstractRedstoneChainBlock` (new Input/Output). This order matters because:
1. Connector extends AbstractRedstoneChainBlock, so checking Abstract first would match Connector too
2. RedstoneChainBlock does NOT extend AbstractRedstoneChainBlock, so it needs its own check

### Edge case: entity on a broken block
`getSignal()` might be called during block removal when the block state is transitioning. The Connector guard ensures we never crash even during intermediate states.
<!-- SECTION:NOTES:END -->

## Definition of Done
<!-- DOD:BEGIN -->
- [ ] #1 `computeNetworkInputPower()` only scans neighbors of positions where block is `instanceof RedstoneInputBlock`
- [ ] #2 `getPowerFromDirection()` returns 0 for `AbstractRedstoneChainBlock` AND `RedstoneChainBlock` neighbors
- [ ] #3 `applySignalToNetwork()` skips `RedstoneConnectorBlock` positions (no `state.getValue(POWER)` call)
- [ ] #4 `applySignalToNetwork()` correctly updates POWER on both `RedstoneInputBlock` and `RedstoneOutputBlock` positions
- [ ] #5 `getSignal()` returns 0 when block is `instanceof RedstoneConnectorBlock` (avoids crash)
- [ ] #6 `getConnectedChains()` still works unchanged (checks `instanceof RedstoneChainEntity`)
- [ ] #7 Legacy `RedstoneChainBlock` still works in pure legacy networks (no regressions)
- [ ] #8 Mixed networks (legacy + new blocks) don't crash
- [ ] #9 No infinite loops or feedback regressions
- [ ] #10 Project compiles with `./gradlew build`
<!-- DOD:END -->
