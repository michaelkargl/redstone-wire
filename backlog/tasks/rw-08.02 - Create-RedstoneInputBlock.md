---
id: RW-08.02
title: Create RedstoneInputBlock
status: To Do
assignee: []
created_date: '2026-02-14 19:41'
updated_date: '2026-02-14 19:49'
labels:
  - feature
milestone: m-1
dependencies:
  - RW-08.01
references:
  - src/main/java/at/osa/redstonewire/RedstoneChainBlock.java
parent_task_id: RW-08
priority: high
---

## Description

<!-- SECTION:DESCRIPTION:BEGIN -->
Create the Input block that detects external redstone signals and feeds them into the cable network.

Extends AbstractRedstoneChainBlock:
- Adds POWER property (0-15) via createBlockStateDefinition() and registers default state with POWER=0
- neighborChanged() — detects external signal changes, calls entity.updateSignalInNetwork(). Ignores neighbors that are instanceof AbstractRedstoneChainBlock or legacy RedstoneChainBlock (prevents feedback loops)
- isSignalSource() returns false (does NOT emit to neighbors)
- getSignal() returns 0 (does NOT emit)
- getDirectSignal() returns 0
- hasAnalogOutputSignal() returns true (comparators can read detected input level)
- getAnalogOutputSignal() returns POWER value
- onPlace() schedules entity update for initial signal detection
- getTicker() overrides base to return RedstoneChainEntity::tick (only Input blocks tick for periodic self-correction)
<!-- SECTION:DESCRIPTION:END -->

## Acceptance Criteria
<!-- AC:BEGIN -->
- [ ] #1 RedstoneInputBlock.java exists extending AbstractRedstoneChainBlock
- [ ] #2 Has POWER property (0-15) with default state POWER=0
- [ ] #3 neighborChanged() triggers entity.updateSignalInNetwork() for non-chain-block neighbors
- [ ] #4 isSignalSource() returns false, getSignal() returns 0, getDirectSignal() returns 0
- [ ] #5 Comparator can read the input signal level via getAnalogOutputSignal()
- [ ] #6 getTicker() returns RedstoneChainEntity::tick for periodic updates
- [ ] #7 onPlace() triggers initial signal detection
<!-- AC:END -->

## Implementation Plan

<!-- SECTION:PLAN:BEGIN -->
## Implementation Plan

### 1. Create `RedstoneInputBlock.java`
Location: `src/main/java/at/osa/redstonewire/RedstoneInputBlock.java`

### 2. Class structure
```java
public class RedstoneInputBlock extends AbstractRedstoneChainBlock {
    public static final IntegerProperty POWER = BlockStateProperties.POWER;

    public RedstoneInputBlock(Properties properties) {
        super(properties);
        this.registerDefaultState(this.stateDefinition.any().setValue(POWER, 0));
    }

    @Override
    protected void createBlockStateDefinition(Builder builder) {
        builder.add(POWER);
    }

    // neighborChanged() — call entity.updateSignalInNetwork()
    //   Guard: skip if neighbor instanceof AbstractRedstoneChainBlock || RedstoneChainBlock
    // isSignalSource() → false
    // getSignal() → 0
    // getDirectSignal() → 0
    // hasAnalogOutputSignal() → true
    // getAnalogOutputSignal() → state.getValue(POWER)
    // getTicker() → override to return RedstoneChainEntity::tick
    // onPlace() → schedule tick for initial detection
}
```

### 3. Key decisions
- `neighborChanged()` only triggers for non-chain neighbors (prevents feedback loops)
- No fallback to `scheduleTick` like the legacy block — Input always uses entity-based network updates
- `getTicker()` overrides the base class null to enable periodic self-correction
- `onPlace()` triggers initial signal detection so placing next to a lever works immediately

### 4. Verify
- Compiles with `./gradlew build`
<!-- SECTION:PLAN:END -->

## Implementation Notes

<!-- SECTION:NOTES:BEGIN -->
## Implementation Notes

### neighborChanged() — the critical method
This is where Input differs from legacy. The legacy block has a fallback path for blocks without entities (adjacent-only). The Input block ONLY operates via entity networks:
```java
if (!level.isClientSide && !(neighborBlock instanceof AbstractRedstoneChainBlock)
                        && !(neighborBlock instanceof RedstoneChainBlock)) {
    BlockEntity be = level.getBlockEntity(pos);
    if (be instanceof RedstoneChainEntity chain) {
        chain.updateSignalInNetwork();
    }
}
```
No `else` branch with `scheduleTick` — Input blocks always have entities.

### Why Input does NOT emit signals
Input blocks detect external signals and feed them into the network. If they also emitted signals, you'd get feedback loops: Input detects its own output via a neighbor. By returning `false` from `isSignalSource()` and `0` from `getSignal()`, the Input block is invisible to redstone neighbors as a power source.

### getTicker() override
The base class returns `null`. Input overrides to return `RedstoneChainEntity::tick`, which periodically calls `updateSignalInNetwork()`. This means only Input blocks drive the periodic self-correction heartbeat. Output and Connector blocks sharing the same network benefit because `updateSignalInNetwork()` propagates to the whole network via `applySignalToNetwork()`.

### onPlace() behavior
Schedule a tick or directly call `updateSignalInNetwork()` so that placing an Input block next to an already-powered lever immediately picks up the signal. The legacy block uses `scheduleTick(pos, this, 1)`. For Input, we can do the same or directly get the entity and call update. Using scheduleTick is safer as it ensures the block entity is fully initialized.

### POWER property duplication
Both `RedstoneInputBlock` and `RedstoneOutputBlock` define `public static final IntegerProperty POWER = BlockStateProperties.POWER`. This is intentional — they're separate block types with separate blockstate definitions. The entity code references POWER via `state.getValue(BlockStateProperties.POWER)` which works for both.
<!-- SECTION:NOTES:END -->

## Definition of Done
<!-- DOD:BEGIN -->
- [ ] #1 New file `RedstoneInputBlock.java` exists in `at.osa.redstonewire` package
- [ ] #2 Class extends `AbstractRedstoneChainBlock`
- [ ] #3 Defines `POWER` property via `createBlockStateDefinition(builder.add(POWER))`
- [ ] #4 Constructor calls `registerDefaultState(stateDefinition.any().setValue(POWER, 0))`
- [ ] #5 `neighborChanged()` calls `entity.updateSignalInNetwork()` when neighbor is NOT `instanceof AbstractRedstoneChainBlock` and NOT `instanceof RedstoneChainBlock`
- [ ] #6 `isSignalSource()` returns `false`
- [ ] #7 `getSignal()` returns `0`, `getDirectSignal()` returns `0`
- [ ] #8 `hasAnalogOutputSignal()` returns `true`, `getAnalogOutputSignal()` returns POWER value
- [ ] #9 `getTicker()` returns `RedstoneChainEntity::tick` (overrides base null)
- [ ] #10 `onPlace()` schedules entity update via `level.scheduleTick(pos, this, 1)` or direct call
- [ ] #11 Project compiles with `./gradlew build`
<!-- DOD:END -->
